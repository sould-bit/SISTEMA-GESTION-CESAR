SISALCHI ‚Äî Documento de Requisitos,
Arquitectura y Plan de Desarrollo
Versi√≥n: 1.0
Autor: Jhon (cliente) / Equipo de desarrollo
Resumen: Este documento consolida todos los acuerdos, decisiones de arquitectura, requerimientos
funcionales y no funcionales, y la hoja de ruta ordenada por prioridades para el desarrollo del sistema
SISALCHI ‚Äî Sistema Integral de Pedidos y Control Interno para Salchipaper√≠as.

1.  Informaci√≥n general del proyecto
    Nombre del sistema: SISALCHI ‚Äî Sistema Integral de Pedidos y Control Interno para Salchipaper√≠as
    Objetivo: Construir un sistema que gestione pedidos (mesas, para llevar, domicilios), comandas para
    cocina, control de domiciliarios, caja, inventario con recetas, reportes y asignaci√≥n inteligente de
    repartidores. La presentaci√≥n para clientes ser√° una PWA (React + TypeScript + Tailwind + Redux Toolkit).
    Toda la l√≥gica financiera y operativa cr√≠tica reside en el backend (FastAPI + SQLModel + PostgreSQL).
    Alcance inicial: MVP desktop/tienda PWA + backend + m√≥dulo opcional de app nativa para
    domiciliarios.
    
Uso del sistema por parte de los clientes (PWA Cliente)

La soluci√≥n contempla una aplicaci√≥n web tipo PWA para los clientes finales, a la cual podr√°n acceder desde un c√≥digo QR ubicado en mesas, empaques o publicidad. Esta aplicaci√≥n permitir√° que los clientes realicen pedidos directamente, sin necesidad de escribir por WhatsApp ni esperar respuesta del negocio.

Caracter√≠sticas principales de la PWA Cliente:

Men√∫ visual completamente administrable desde el panel del negocio.

Selecci√≥n de productos, extras, tama√±os o notas.

Elecci√≥n del tipo de pedido: Mesa (con n√∫mero de mesa), Para Llevar o Domicilio.

Registro opcional de cliente (nombre, tel√©fono, direcci√≥n para domicilios).

Env√≠o del pedido directamente al backend ‚Üí cocina ‚Üí caja.

Recepci√≥n de actualizaciones en tiempo real ("Tu pedido est√° en preparaci√≥n", "Tu pedido est√° listo").

Integraci√≥n con pasarela de pagos en fases futuras.

Impacto en los dolores del negocio:

Elimina la dependencia de WhatsApp para recibir pedidos.

Ahorra tiempo al personal y reduce errores en la toma de √≥rdenes.

Crea trazabilidad completa del pedido desde el cliente hasta la entrega.

Permite operar m√°s mesas con menos personal.

2.  Arquitectura seleccionada (oficial)
    2.1 Frontend
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    Stack: React + TypeScript + TailwindCSS + Redux Toolkit
    Distribuci√≥n: PWA desplegada en Vercel/Netlify/Cloudflare Pages
    Responsabilidad: Capa de presentaci√≥n; no contiene l√≥gica cr√≠tica (no c√°lculos financieros ni
    validaciones de inventario).
    2.2 Backend
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    Stack: FastAPI + SQLModel + PostgreSQL
    Responsabilidad: √önica fuente de verdad; contiene toda la l√≥gica de negocio, validaciones,
    c√°lculos financieros, consecutivos, cuadres y auditor√≠a.
    Despliegue recomendado: VPS (Contabo/Hetzner/DigitalOcean) ‚Äî plan b√°sico desde ~5 USD/
    mes.
    2.3 App nativa (opcional)
    ‚Ä¢
    ‚Ä¢
    Plataforma: Android nativa simple (o Flutter si se desea multi-plataforma en futuro)
    Uso: Domiciliarios ‚Äî login, recepci√≥n de pedidos, env√≠o de ubicaci√≥n, confirmaci√≥n de entrega
    con GPS y detecci√≥n de proximidad al local.
    1
3.  Requerimientos resumen (funcionales principales)
    (Resumido ‚Äî el documento completo de requisitos se mantiene en la secci√≥n
    Documents / Requisitos)
4.
5.
6.
7.
8.
9.
10.
11.
12. Gesti√≥n de productos y recetas (receta obligatoria para que el descuento autom√°tico funcione).
    Pedidos: Mesa (M-XXX), Para Llevar (L-XXX), Domicilio (D-XXX). Consecutivos en backend.
    Comandas imprimibles para cocina (impresora t√©rmica USB).
    Control de domiciliarios: asignaci√≥n manual/autom√°tica, registro de entregas, cuadre de turnos.
    Inventario: insumos, unidades, entradas, movimientos, descuento autom√°tico por receta.
    Caja y cierres: registro de m√©todos de pago, cuadre esperado vs real, reporte de diferencias.
    Reportes: ventas, inventario, domiciliarios, consumo por producto.
    Seguridad: roles (Administrador, Cajero, Cocina, Domiciliario), autenticaci√≥n JWT.
    Auditor√≠a: logs de acciones cr√≠ticas.
13. Requerimientos no funcionales (resumen)
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    Sistema local-first: debe poder correr con base de datos local en VPS o incluso en LAN para
    modo offline.
    Rendimiento: respuesta < 300 ms para endpoints cr√≠ticos; soportar 200 pedidos/d√≠a m√≠nimo.
    Seguridad: transportes via HTTPS; contrase√±as hasheadas (bcrypt); roles y permisos.
    Disponibilidad: backups regulares; recuperaci√≥n ante corte de energ√≠a (persistencia de datos
    locales).
14. Modelo de datos (resumen de tablas clave)
    üü• 1. Tabla: usuarios

Usuarios del sistema (Administrador, Cajero, Cocina, Domiciliario).

Campo Tipo Descripci√≥n
id (PK) int identificador
nombre varchar nombre completo
usuario varchar unique login
contrase√±a_hash varchar hash bcrypt
rol enum(admin, cajero, cocina, domiciliario) rol del sistema
activo bool si puede iniciar sesi√≥n
creado_en timestamp fecha registro
üüß 2. Tabla: categorias

Categor√≠as de productos.

Campo Tipo
id (PK) int
nombre varchar
üü® 3. Tabla: productos

Productos del men√∫.

Campo Tipo
id (PK) int
nombre varchar
descripcion varchar
precio numeric(12,2)
categoria_id (FK) ‚Üí categorias.id int
activo bool

Relaci√≥n:

1 categor√≠a ‚Üí muchos productos

üü© 4. Tabla: insumos

Insumos del inventario (papa, salchicha, aceite‚Ä¶).

Campo Tipo
id (PK) int
nombre varchar
unidad_medida varchar (ej: g, ml, unidades)
stock_actual numeric
stock_minimo numeric
costo_promedio numeric(12,4)
activo bool
üü¶ 5. Tabla: recetas

Una receta por producto.

Campo Tipo
id (PK) int
producto_id (FK) ‚Üí productos.id int
descripcion text

Relaci√≥n:

1 producto ‚Üí 1 receta

üü™ 6. Tabla: receta_detalle

Ingredientes con cantidad por producto.

Campo Tipo
id (PK) int
receta_id (FK) ‚Üí recetas.id int
insumo_id (FK) ‚Üí insumos.id int
cantidad numeric

Relaciones:

N ingredientes ‚Üí 1 receta

Muchos ingredientes ‚Üí muchos insumos

üü´ 7. Tabla: inventario_movimientos

Movimientos de inventario (entradas, salidas, ajustes).

Campo Tipo
id (PK) int
insumo_id (FK) int
tipo enum(entrada, salida, ajuste)
cantidad numeric
costo_unitario numeric(12,4) NULL
motivo varchar
referencia varchar (id pedido o nota)
usuario_id (FK) int
creado_en timestamp
üü• 8. Tabla: pedidos

Pedidos principales.

Campo Tipo
id (PK) int
consecutivo varchar unique (M-001, L-002, D-003)
tipo enum(mesa, llevar, domicilio)
mesa varchar NULL
cliente_nombre varchar NULL
cliente_telefono varchar NULL
direccion varchar NULL
estado enum(pendiente, en_preparacion, listo, entregado, cancelado)
total numeric(12,2)
domiciliario_id (FK) ‚Üí usuarios.id int NULL
creado_por (FK) ‚Üí usuarios.id int
creado_en timestamp
actualizado_en timestamp
üüß 9. Tabla: detalle_pedidos

Productos espec√≠ficos dentro del pedido.

Campo Tipo
id (PK) int
pedido_id (FK) int
producto_id (FK) int
cantidad int
precio_unitario numeric(12,2)
subtotal numeric(12,2)
üü® 10. Tabla: pagos

M√©todos de pago de cada pedido.

Campo Tipo
id (PK) int
pedido_id (FK) int
metodo enum(efectivo, transferencia, dat√°fono)
monto numeric(12,2)
referencia varchar NULL
creado_en timestamp
üü© 11. Tabla: cierres_caja

Cierres de jornada por cajero.

Campo Tipo
id (PK) int
usuario_id (FK) int
total_esperado numeric
total_real numeric
diferencia numeric
notas text NULL
creado_en timestamp
üü¶ 12. Tabla: domiciliarios_ubicacion

Historial de ubicaciones GPS.

Campo Tipo
id (PK) int
domiciliario_id (FK) int
lat numeric
lng numeric
creado_en timestamp
üü™ 13. Tabla: domiciliarios_estado

Estado del domiciliario.

Campo Tipo
id (PK) int
domiciliario_id (FK) int
estado enum(disponible, en_ruta, entregando, en_negocio)
actualizado_en timestamp
üü´ 14. Tabla: configuraciones

Par√°metros del sistema.

Campo Tipo
id (PK) int
clave varchar
valor varchar
üñ®Ô∏è 15. Tabla: logs

Auditor√≠a de cambios cr√≠ticos.

Campo Tipo
id (PK) int
usuario_id (FK) int
accion varchar
entidad varchar
entidad_id int
detalle text
creado_en timestamp
üß† RELACIONES (resumen visual)

usuarios
‚Ü≥ crea pedidos, movimientos, cierres, logs

categorias ‚Üí productos ‚Üí recetas ‚Üí receta_detalle ‚Üí insumos
Cadena que permite descontar inventario autom√°ticamente.

pedidos ‚Üí detalle_pedidos ‚Üí productos

pedidos ‚Üí pagos

pedidos ‚Üí domiciliarios (solo si tipo = domicilio)

domiciliarios_ubicacion, domiciliarios_estado
‚Ü≥ relacionados al usuario domiciliario.
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
usuarios
categorias
productos
recetas
receta_detalle
pedidos
detalle_pedidos
domiciliarios
domiciliarios_ubicacion
domiciliarios_estado
insumos
inventario_movimientos
pagos
cierres_caja
reportes
configuraciones
(El modelo ER detallado quedar√° en el anexo y se generar√° como diagrama ER en la siguiente tarea).
2 15. Endpoints API (resumen esencial)
Nota: todos los endpoints que modifican dinero, inventario o estados cr√≠ticos se ejecutan
en transacci√≥n y validan en backend.
Auth - POST /auth/token ‚Äî obtener JWT - GET /auth/me ‚Äî datos del usuario
Productos - GET /products - POST /products - PUT /products/{id} - DELETE /products/{id} - POST /
products/{id}/recipe ‚Äî crear/actualizar receta
Pedidos - POST /orders ‚Äî crear pedido (backend genera total y consecutivo) - GET /orders/{id} - GET /
orders?estado= - POST /orders/{id}/status ‚Äî cambiar estado (server-side validation) - POST /orders/{id}/
assign ‚Äî asignar domiciliario (manual)
Cocina - GET /kitchen/orders ‚Äî pedidos por preparar - POST /kitchen/orders/{id}/start - POST /kitchen/
orders/{id}/ready
Inventario - GET /inventory - POST /inventory/entries ‚Äî registrar entrada - POST /inventory/
movements ‚Äî registro manual/ajuste - GET /inventory/report
Domiciliarios - POST /domiciliary/login - GET /domiciliary/me - GET /domiciliary/assigned - POST /
domiciliary/{id}/location ‚Äî actualizar ubicaci√≥n - POST /domiciliary/{id}/delivered ‚Äî marcar entrega
(captura GPS)
Caja y reportes - GET /reports/daily - POST /cash/close ‚Äî cierre de caja (backend calcula totales
esperados) - GET /reports/domiciliarios/{id} 16. Reglas claves de dise√±o e integridad 17. 18. 19. 20. 21. Backend como fuente de la verdad: Todos los c√°lculos financieros, de consecutivos y de
inventario se realizan y validan en el backend.
Transacciones SQL: Operaciones que afectan inventario + ventas deben realizarse como
transacci√≥n at√≥mica.
Logs y auditor√≠a: Cada cambio cr√≠tico (ajuste de inventario, cierre de caja, eliminaci√≥n de
pedido) debe registrarse con usuario y motivo.
Validaci√≥n de stock: Antes de confirmar venta, validar stock te√≥rico y reservar insumos en la
misma transacci√≥n.
Concurrencia: Generaci√≥n de consecutivos e inventario debe ser segura frente a concurrencia
(bloqueos o secuencias en DB).
7.5 M√≥dulo WebSockets ‚Äî Tiempo Real (NUEVO)
Objetivo: Proveer comunicaci√≥n en tiempo real entre Caja, Cocina y Domiciliarios mediante Socket.IO.
Canales oficiales: - /kitchen-channel: Emite
newOrder ,
printComanda . - /dispatcher-channel: Emite
orderUpdated ,
orderCanceled ,
assignment ,
newDelivery ,
locationUpdate ,
deliveryComplete ,
domAvailable .
3
Caracter√≠sticas clave: 1. WebSockets solo informan, NO procesan l√≥gica cr√≠tica. 2. Se usa Socket.IO
(python-socketio) para reconexi√≥n autom√°tica. 3. Cada domiciliario se une a una "room" identificada
(dom\_{id}) para recibir pedidos asignados. 4. Cocina se mantiene sincronizada sin refrescar. 5. Caja ve
actualizaciones de estados en vivo.
Entregables: Servidor WebSockets, integraci√≥n con eventos del sistema, rooms para domiciliarios,
hooks para frontend. 22. Flujo de desarrollo (orden y entregables)
A continuaci√≥n presento la hoja de ruta y la prioridad de desarrollo dividida en 'Fases' para que el
equipo (o t√∫) pueda avanzar por entregables incrementales y probables sprints.
Fase 0 ‚Äî Preparaci√≥n del repositorio (entregable inmediato)
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
Inicializar monorepo con carpetas
backend/ y
frontend/ .
Configurar linter/prettier y CI b√°sico (opcional).
Dockerfile para backend y configuraci√≥n Vite para frontend.
Script de bootstrap (env, variables, README con c√≥mo correr local).
Tiempo estimado (MVP): 1 d√≠a (preparaci√≥n)
Fase 1 ‚Äî N√∫cleo backend (Backend Core) ‚Äî PRIORIDAD ALTA
Objetivo: Implementar la l√≥gica cr√≠tica y endpoints base para operaciones.
Tareas: 1. Estructura de la DB y modelos (SQLModel) +
db.init_db() . 2. Auth JWT (endpoints /auth/
token y /auth/me). 3. CRUD Productos y Recetas (incluye validaci√≥n de receta obligatoria si aplica). 4.
Inventario: tablas de insumos y movimientos. 5. Router
/orders completo: - Generaci√≥n de
consecutivos M/L/D (segura con transacci√≥n). - C√°lculo de total (precio producto + extras) en backend.
Descuento autom√°tico de inventario con comprobaciones de stock. - Estado inicial y eventos (pendiente
‚Üí en_preparacion ‚Üí listo ‚Üí entregado). 6. Endpoints para cocina (start/ready). 7. Unit tests b√°sicos
para creaci√≥n de pedido y ajuste de inventario.
Entregables: API funcional con Postman collection.
Prioridad: Cr√≠tica (sin esto nada funciona)
Fase 2 ‚Äî M√≥dulo Caja, Cierres y Reportes ‚Äî PRIORIDAD ALTA
Objetivo: Cierre de flujo financiero y reportes que permiten cuadre.
Tareas: 1. Registrar pagos por pedido (efectivo, transferencia, dat√°fono). 2. Endpoint
POST /cash/
close que calcule esperado vs real y registre diferencias. 3. Reportes diarios: ventas por tipo, ventas
por categor√≠a, productos top. 4. Reporte por domiciliario (pedidos, montos, diferencias).
Entregables: Endpoints de cierre y reportes + UI m√≠nima en PWA para visualizar.
4
Fase 3 ‚Äî M√≥dulo Domiciliarios (Asignaci√≥n y App nativa) ‚Äî PRIORIDAD MEDIA
Objetivo: Control y cuadre de domiciliarios.
Tareas: 1. CRUD domiciliarios, login y estado. 2. Endpoints de ubicaci√≥n y entrega con captura GPS. 3.
L√≥gica de asignaci√≥n inteligente (activar/desactivar desde admin). 4. Endpoint para listar domiciliarios
disponibles. 5. Plantilla simple de app nativa (proof of concept) o documentaci√≥n de API para la app.
Entregables: API con asignaci√≥n inteligente, pruebas de asignaci√≥n y ejemplo de app m√≥vil ligera.
Fase 4 ‚Äî Inventario avanzado y costes ‚Äî PRIORIDAD MEDIA
Objetivo: Mejorar control de costos y consumos.
Tareas: 1. Costeo por receta (costo unitario por plato usando promedio ponderado de entradas). 2.
Alertas de stock m√≠nimo y notificaciones. 3. Ajustes masivos, importaci√≥n de insumos. 4. Reportes de
consumo y p√©rdidas.
Entregables: Reportes de Costo-Venta y alertas configurables.
Fase 5 ‚Äî Frontend PWA (React + TS + Tailwind + Redux) ‚Äî PRIORIDAD ALTA
(paralela)
Objetivo: Interfaz robusta que consuma la API (sin l√≥gica cr√≠tica en cliente).
Tareas iniciales (ordenadas): 1. Estructura del proyecto y configuraci√≥n (Vite + TS + Tailwind). 2.
Implementar slices de Redux: auth, products, orders, inventory, domiciliarios. 3. Pantallas: Login,
Dashboard, Products, Create Order (Mesa / Llevar / Domicilio), Kitchen View, Inventory, Reports,
Domiciliarios. 4. Integraci√≥n de impresi√≥n (PDF o llamada a endpoint que retorne contenido para
imprimir en cocina). 5. PWA manifest y service worker.
Entregables: PWA desplegada en Vercel con conexi√≥n a backend de staging.
Fase 6 ‚Äî QA, Documentaci√≥n y Entrega al Cliente
Tareas: 1. Pruebas end-to-end (crear pedido, preparar, entregar, cierre de caja) con datos reales. 2.
Documentaci√≥n de uso (manual de usuario para cajero, cocina y administrador). 3. Instalador (si se
desea modo offline en un PC del local) o gu√≠as para deploy en VPS. 4. M√≠nimo 1 sesi√≥n de capacitaci√≥n
para el cliente.
Entregables: Sistema listo en producci√≥n y manuales.
5 23. Orden de desarrollo sugerido (lista concreta de tickets)
A continuaci√≥n lista de tickets (puedes pegarlos en tu gestor: Trello/Notion/Jira) por orden prioritario: 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. INIT-REPO: Crear repositorio, .gitignore, README, estructura inicial.
DB-MODELS: Crear modelos SQLModel y script de migraci√≥n/inicializaci√≥n.
AUTH: Implementar JWT auth y seed admin user.
PRODUCTS-CRUD: Endpoints productos y recetas.
INVENTORY-BASIC: Insumos + movimientos + entradas.
ORDERS-BASIC: POST /orders con consecutivo y c√°lculo total (sin asignaci√≥n domiciliario).
INVENTORY-DEDUCT: Descuento autom√°tico de insumos por receta al crear pedido.
KITCHEN-ENDPOINTS: start/ready endpoints.
PRINT-SIM: Endpoint que genere payload imprimible para comandas.
PAYMENTS: Registrar pagos por pedido.
CASH-CLOSE: Endpoint cierre de caja y reportes b√°sicos.
REPORTS: Endpoints de reportes diarios y por domiciliario.
DOMICILIARY-BASIC: CRUD y login domiciliarios.
DOMICILIARY-LOCATION: Endpoints ubicaci√≥n y delivered (con GPS validation).
ASSIGN-AI: Asignaci√≥n inteligente autom√°tica.
FRONTEND-INIT: Crear proyecto React+TS+Tailwind+RTK.
FRONTEND-PAGES: Login, Products, CreateOrder, KitchenView.
FRONTEND-PRINTING: Integraci√≥n de impresi√≥n de comandas.
INVENTORY-ADV: Costeo por receta y reportes de consumo.
QA: E2E tests y correcciones.
DEPLOY: VPS setup, CI/CD, dominio, TLS.
DOCS: Manuales y entrenamiento. 46. Infraestructura y costos (resumen)
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
Frontend PWA: Hosting gratuito en Vercel/Netlify.
Backend + DB: VPS (Contabo/Hetzner/DigitalOcean) ‚âà $4‚Äì7 USD/mes.
Dominio (opcional): ‚âà $10‚Äì12 USD/a√±o.
App nativa (opcional): coste de desarrollo aparte (pagar al desarrollador o usar Flutter para
cross-platform).
Backup y monitoring: considerar servicio adicional o scripts de backup (puede operar con cron

- dump).
  Plan de soporte sugerido para el cliente: cobrar COP 50.000‚Äì70.000 / mes por hosting y soporte.

11. Gu√≠a de desarrollo (setup r√°pido)
    Backend local:
    cd backend
    python-m venv .venv
    source .venv/bin/activate # windows: .venv\Scripts\activate
    6
    pip install-r requirements.txt
    uvicorn app.main:app--reload--port 8000
    Frontend local:
    cd frontend
    npm install
    npm run dev
    Docker (opcional): - Build backend:
    docker build -t sisalchi-backend ./backend - Run:
    docker run -p 8000:8000 sisalchi-backend
12. Criterios de aceptaci√≥n por m√≥dulo (QA checklist corto)
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    Orders: Crear pedido devuelve consecutivo √∫nico generado por servidor; inventario se
    descuenta; pedido aparece en kitchen view.
    Inventory: Entrada de insumo incrementa stock; venta descuenta correctamente; alerta en
    stock m√≠nimo.
    Domiciliarios: Login, recepci√≥n de pedido y entrega con GPS validado.
    Caja: Cierre de caja muestra totales esperados; se registran diferencias.
    Frontend: Todas las acciones cr√≠ticas son invocadas v√≠a API; cliente no calcula totales.
13. Pr√≥ximo paso inmediato (acci√≥n recomendada)
    Comenzar la Fase 0 e inmediatamente arrancar la Fase 1: Backend Core. El primer ticket cr√≠tico a
    implementar es: DB-MODELS y AUTH para poder seedear un usuario admin y empezar a crear
    productos/recetas y pedidos.
    Anexos y documentaci√≥n complementaria
    ‚Ä¢
    ‚Ä¢
    Men√∫ del cliente (adjunto: Men√∫ rincon.pdf)
    Documentos previos: Requisitos detallados, flujos de uso, propuestas de hosting.
    Fin del documento.
14. Diagramas de Arquitectura y Flujos en Tiempo Real
    14.1 Diagrama General de Arquitectura (Mermaid)
    graph TD;
    A[Cliente PWA - React] -- REST --> B[Backend FastAPI]
    7
    A -- WebSocket --> C[Socket.IO Server]
    B -- SQL --> D[(PostgreSQL)]
    B -- Emit eventos --> C
    C -- Push tiempo real --> E[Pantalla Cocina]
    C -- Push tiempo real --> F[App Domiciliario]
    E -- peticiones REST --> B
    F -- REST + WS --> B
    14.2 Flujo Detallado: Pedido creado (Caja ‚Üí Cocina)
    sequenceDiagram
    actor Cajero
    participant Frontend as PWA
    participant Backend as FastAPI
    participant WS as Socket.IO
    participant Cocina
    Cajero->>Frontend: Crear pedido (UI)
    Frontend->>Backend: POST /orders
    Backend->>Backend: Validar stock + generar consecutivo
    Backend->>Backend: Descontar inventario (transacci√≥n)
    Backend->>WS: Emit "newOrder"
    WS->>Cocina: Evento newOrder (tiempo real)
    Backend-->>Frontend: Respuesta con id del pedido
    14.3 Flujo Detallado: Estado del pedido (Pendiente ‚Üí Preparaci√≥n ‚Üí Listo)
    sequenceDiagram
    participant Cocina
    participant Backend
    participant WS
    participant Caja
    Cocina->>Backend: POST /orders/{id}/status (en*preparacion)
    Backend->>Backend: Validar transici√≥n
    Backend->>WS: Emit "orderUpdated"
    WS->>Caja: Actualizaci√≥n en vivo
    WS->>Cocina: Sincronizaci√≥n entre pantallas
    Cocina->>Backend: POST /orders/{id}/status (listo)
    Backend->>WS: Emit "orderUpdated"
    WS->>Caja: Pedido listo (tiempo real)
    8
    14.4 Flujo Detallado: Asignaci√≥n de domiciliario (Caja ‚Üí Domiciliario)
    sequenceDiagram
    actor Cajero
    participant Backend
    participant WS
    participant Domiciliario
    Cajero->>Backend: POST /orders/{id}/assign
    Backend->>Backend: Validar domiciliario disponible
    Backend->>WS: Emit "assignment" a room dom*{id}
    WS->>Domiciliario: Notificaci√≥n en tiempo real
    14.5 Flujo Detallado: Entrega del pedido (Domiciliario ‚Üí Caja)
    sequenceDiagram
    participant Domiciliario
    participant Backend
    participant WS
    participant Caja
    Domiciliario->>Backend: POST /deliver (con GPS)
    Backend->>Backend: Validar ubicaci√≥n
    Backend->>WS: Emit "deliveryComplete"
    WS->>Caja: Pedido entregado (tiempo real)
    14.6 Diagrama: Estructura de WebSockets (Namespaces y Rooms)
    graph LR;
    subgraph Socket.IO Server
    A[/kitchen-channel/]
    B[/dispatcher-channel/]
    end
    A --> A1(Kitchen UI)
    A --> A2(Caja - modo cocina)
    B --> B1{Room: dom_1}
    B --> B2{Room: dom_2}
    B --> B3{Room: dom_n}
    B1 --> R1[Domiciliario 1]
    9
    B2 --> R2[Domiciliario 2]
    B3 --> Rn[Domiciliario n]
    14.7 Eventos WebSocket Documentados
    Canal /kitchen-channel
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    newOrder ‚Üí Pedido creado
    orderUpdated ‚Üí Cambio de estado
    orderCanceled ‚Üí Pedido anulado
    printComanda ‚Üí Solicitud de impresi√≥n
    Canal /dispatcher-channel
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    assignment ‚Üí Pedido asignado a un domiciliario
    newDelivery ‚Üí Nuevo domicilio disponible
    locationUpdate ‚Üí Actualizaci√≥n de ubicaci√≥n
    deliveryComplete ‚Üí Pedido entregado
    domAvailable ‚Üí Domiciliario cerca del negocio
    14.8 Flujo de impresi√≥n (Caja ‚Üí Cocina)
    sequenceDiagram
    participant Caja
    participant Backend
    participant WS
    participant Cocina
    Caja->>Backend: POST /print/{id}
    Backend->>Backend: Generar payload imprimible
    Backend->>WS: Emit "printComanda"
    WS->>Cocina: Se√±al para imprimir
    Cocina->>impresora: Impresi√≥n t√©rmica
    14.9 Resumen t√©cnico de la integraci√≥n WebSocket
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    ‚Ä¢
    Los WebSockets no manejan l√≥gica cr√≠tica.
    Solo sirven para notificar cambios.
    Todas las pantallas se mantienen sincronizadas sin refrescar.
    Los domiciliarios usan "rooms" privadas.
    Cocina recibe pedidos al instante.
    Caja ve cambios de estado en tiempo real.
    10
